local dns, dnssec = require('dns'), require('dns.dnssec')
local ffi = require('ffi')

local M = {}

-- Sign records in section
local function sign_section(self, section, writer)
	local signer = self.signer
	-- Merge/dedup records before signing
	local dedup, cloned = nil, false
	-- Generate signatures for answers
	local rrsigs = {}
	for _, rr in ipairs(section) do
		if rr:type() ~= dns.type.RRSIG then
			if not dedup then -- First record
				dedup, cloned = rr, false
			elseif not dedup:equals(rr) then -- Different record
				table.insert(rrsigs, signer:sign(dedup))
				dedup, cloned = rr, false
			else -- Record matches, merge it with previous
				if not cloned then
					dedup, cloned = dedup:copy(), true
				end
				dedup:merge(rr)
			end
		end
	end
	if dedup then table.insert(rrsigs, signer:sign(dedup)) end
	-- Write signatures to packet
	for _, rr in ipairs(rrsigs) do
		writer(section, rr)
	end
end

-- Authenticated denial of existence
local function denial(self, req, nxdomain)
	local ttl = 0
	-- Fetch MINTTL from authority SOA
	local soa = req.authority[1]
	if soa and  soa:type() == dns.type.SOA then
		ttl = dns.rdata.soa_minttl(soa:rdata(0))
	end
	local nsec = dnssec.denial(req.query:qname(), req.query:qtype(), ttl, nxdomain)
	-- Add NSEC to authority
	table.insert(req.authority, nsec)
end

-- Sign records in the answer
local function serve(self, req, writer)
	-- Check if we DNSSEC is requested
	if req.xfer or not dns.edns.dobit(req.query.opt) then
		return
	end
	-- If NOERROR or NXDOMAIN, generate denial
	local nxdomain = (req.answer:rcode() == dns.rcode.NXDOMAIN)
	if nxdomain or req.answer:empty() then
		denial(self, req, nxdomain)
		-- Turn NXDOMAIN into NODATA
		if nxdomain then req.answer:rcode(dns.rcode.NOERROR) end
	end
	sign_section(self, req.answer, req.answer.put)
	sign_section(self, req.authority, table.insert)
	sign_section(self, req.additional, table.insert)
	-- Set DNSSEC OK
	dns.edns.dobit(req.opt, true)
	return true
end

-- Set ZSK for record signing
function M.init(conf)
	local key = dnssec.key()
	-- Set key algorithm
	key:algo(dnssec.algo[conf.algo] or dnssec.algo.ecdsa_p256_sha256)
	-- If keyfile is not specified, generate it
	if not conf.key then
		function bytes (t) return string.char(unpack(t)) end
		local pem = bytes {
			0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e,
			0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b,
			0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49,
			0x47, 0x55, 0x41, 0x67, 0x45, 0x41, 0x4d, 0x42, 0x4d, 0x47,
			0x42, 0x79, 0x71, 0x47, 0x53, 0x4d, 0x34, 0x39, 0x41, 0x67,
			0x45, 0x47, 0x43, 0x43, 0x71, 0x47, 0x53, 0x4d, 0x34, 0x39,
			0x41, 0x77, 0x45, 0x48, 0x42, 0x48, 0x6f, 0x77, 0x65, 0x41,
			0x49, 0x42, 0x41, 0x51, 0x51, 0x68, 0x41, 0x49, 0x73, 0x69,
			0x79, 0x44, 0x33, 0x5a, 0x4e, 0x77, 0x7a, 0x69, 0x4d, 0x56,
			0x5a, 0x70, 0x0a, 0x6b, 0x6d, 0x4a, 0x5a, 0x6b, 0x37, 0x4c,
			0x57, 0x37, 0x56, 0x44, 0x34, 0x6c, 0x5a, 0x52, 0x4d, 0x67,
			0x31, 0x2b, 0x4f, 0x71, 0x62, 0x4d, 0x67, 0x73, 0x44, 0x56,
			0x55, 0x6f, 0x41, 0x6f, 0x47, 0x43, 0x43, 0x71, 0x47, 0x53,
			0x4d, 0x34, 0x39, 0x41, 0x77, 0x45, 0x48, 0x6f, 0x55, 0x51,
			0x44, 0x51, 0x67, 0x41, 0x45, 0x38, 0x75, 0x44, 0x37, 0x43,
			0x34, 0x54, 0x48, 0x54, 0x4d, 0x2f, 0x77, 0x0a, 0x37, 0x75,
			0x68, 0x72, 0x79, 0x52, 0x53, 0x54, 0x6f, 0x65, 0x45, 0x2f,
			0x6a, 0x4b, 0x54, 0x37, 0x38, 0x2f, 0x70, 0x38, 0x35, 0x33,
			0x52, 0x58, 0x30, 0x4c, 0x35, 0x45, 0x77, 0x72, 0x5a, 0x72,
			0x53, 0x4c, 0x42, 0x75, 0x62, 0x4c, 0x50, 0x69, 0x42, 0x77,
			0x37, 0x67, 0x62, 0x76, 0x55, 0x50, 0x36, 0x53, 0x73, 0x49,
			0x67, 0x61, 0x35, 0x5a, 0x51, 0x34, 0x43, 0x53, 0x41, 0x78,
			0x4e, 0x6d, 0x0a, 0x59, 0x41, 0x2f, 0x67, 0x5a, 0x73, 0x75,
			0x58, 0x7a, 0x41, 0x3d, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d,
			0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
			0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d,
			0x2d, 0x0a,
		}
		key:privkey(pem) -- TODO this is just sample key
	end
	-- Return signer context
	assert(key:can_sign(), 'given key cannot be used for signing')
	local signer = dnssec.signer(key)
	return {key=key, signer=signer, serve=serve}
	
end

return M